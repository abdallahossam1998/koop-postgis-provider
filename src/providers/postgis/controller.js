const Model = require('./model')

class Controller {
  constructor() {
    this.model = new Model()
  }

  /**
   * Handle FeatureServer requests
   */
  async featureServer(req, res) {
    try {
      const { layer, method } = req.params
      
      // Handle different FeatureServer methods
      switch (method) {
        case 'query':
          return this.handleQuery(req, res)
        case 'info':
          return this.handleLayerInfo(req, res)
        default:
          if (!method && layer) {
            return this.handleLayerInfo(req, res)
          } else if (!method && !layer) {
            return this.handleServiceInfo(req, res, 'FeatureServer')
          }
          return this.handleQuery(req, res)
      }
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Handle MapServer requests
   */
  async mapServer(req, res) {
    try {
      const { layer, method } = req.params
      
      // Handle different MapServer methods
      switch (method) {
        case 'query':
          return this.handleQuery(req, res)
        case 'info':
          return this.handleLayerInfo(req, res)
        default:
          if (!method && layer) {
            return this.handleLayerInfo(req, res)
          } else if (!method && !layer) {
            return this.handleServiceInfo(req, res, 'MapServer')
          }
          return this.handleQuery(req, res)
      }
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Handle query requests
   */
  async handleQuery(req, res) {
    try {
      // Use Koop's standard getData method
      this.model.getData(req, (error, geojson) => {
        if (error) {
          return this.handleError(res, error)
        }

        // Handle different response formats
        const f = req.query.f || 'json'
        
        if (f === 'geojson') {
          res.json(geojson)
        } else if (req.query.returnCountOnly === 'true') {
          res.json({
            count: geojson.features.length
          })
        } else if (req.query.returnIdsOnly === 'true') {
          const ids = geojson.features.map(feature => {
            const idField = geojson.metadata.idField
            return idField ? feature.properties[idField] : null
          }).filter(id => id !== null)
          
          res.json({
            objectIdFieldName: geojson.metadata.idField || 'OBJECTID',
            objectIds: ids
          })
        } else {
          // Convert to Esri JSON format
          const esriJson = this.convertToEsriJson(geojson, req.query)
          res.json(esriJson)
        }
      })
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Handle layer info requests
   */
  async handleLayerInfo(req, res) {
    try {
      this.model.getData(req, (error, geojson) => {
        if (error) {
          return this.handleError(res, error)
        }

        const layerInfo = this.generateLayerInfo(geojson.metadata, req.params)
        res.json(layerInfo)
      })
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Handle service info requests
   */
  async handleServiceInfo(req, res, serviceType) {
    try {
      const { host, id } = req.params
      
      const serviceInfo = {
        currentVersion: 10.91,
        serviceDescription: `PostgreSQL/PostGIS ${serviceType} for ${id}`,
        mapName: id,
        description: `PostgreSQL/PostGIS layer: ${id}`,
        copyrightText: '',
        supportsDynamicLayers: false,
        layers: [
          {
            id: 0,
            name: id,
            parentLayerId: -1,
            defaultVisibility: true,
            subLayerIds: null,
            minScale: 0,
            maxScale: 0,
            type: 'Feature Layer',
            geometryType: 'esriGeometryPoint'
          }
        ],
        tables: [],
        spatialReference: {
          wkid: 4326,
          latestWkid: 4326
        },
        singleFusedMapCache: false,
        initialExtent: {
          xmin: -180,
          ymin: -90,
          xmax: 180,
          ymax: 90,
          spatialReference: {
            wkid: 4326,
            latestWkid: 4326
          }
        },
        fullExtent: {
          xmin: -180,
          ymin: -90,
          xmax: 180,
          ymax: 90,
          spatialReference: {
            wkid: 4326,
            latestWkid: 4326
          }
        },
        minScale: 0,
        maxScale: 0,
        units: 'esriDecimalDegrees',
        supportedImageFormatTypes: 'PNG32,PNG24,PNG,JPG,DIB,TIFF,EMF,PS,PDF,GIF,SVG,SVGZ,BMP',
        documentInfo: {
          Title: `${serviceType} for ${id}`,
          Author: 'Koop PostgreSQL/PostGIS Provider',
          Comments: 'Generated by Koop',
          Subject: `PostgreSQL/PostGIS ${serviceType}`,
          Category: '',
          AntialiasingMode: 'None',
          TextAntialiasingMode: 'Force',
          Keywords: 'koop,postgis,postgresql'
        },
        capabilities: 'Map,Query,Data',
        supportedQueryFormats: 'JSON, geoJSON',
        supportedExportFormats: 'sqlite,filegdb,shapefile,csv,kml,kmz',
        hasVersionedData: false,
        maxRecordCount: parseInt(process.env.KOOP_MAX_RECORD_COUNT) || 100000,
        maxImageHeight: 4096,
        maxImageWidth: 4096,
        supportedExtensions: ''
      }

      res.json(serviceInfo)
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Handle general info requests
   */
  async info(req, res) {
    try {
      const { host, id } = req.params
      
      const info = {
        name: id,
        type: 'PostgreSQL/PostGIS Provider',
        description: `PostgreSQL/PostGIS data source: ${id}`,
        host: host,
        services: [
          {
            name: 'FeatureServer',
            url: `${req.protocol}://${req.get('host')}${req.originalUrl}/FeatureServer`
          },
          {
            name: 'MapServer', 
            url: `${req.protocol}://${req.get('host')}${req.originalUrl}/MapServer`
          }
        ]
      }

      res.json(info)
    } catch (error) {
      this.handleError(res, error)
    }
  }

  /**
   * Convert GeoJSON to Esri JSON format
   */
  convertToEsriJson(geojson, queryParams) {
    const features = geojson.features.map(feature => {
      const esriFeature = {
        attributes: feature.properties || {},
        geometry: this.convertGeometryToEsri(feature.geometry)
      }
      return esriFeature
    })

    const result = {
      objectIdFieldName: geojson.metadata.idField || 'OBJECTID',
      uniqueIdField: {
        name: geojson.metadata.idField || 'OBJECTID',
        isSystemMaintained: true
      },
      globalIdFieldName: '',
      geometryType: this.mapGeometryTypeToEsri(geojson.metadata.geometryType),
      spatialReference: {
        wkid: 4326,
        latestWkid: 4326
      },
      fields: this.convertFieldsToEsri(geojson.metadata.fields),
      features: features
    }

    // Add count information if available
    if (queryParams.returnCountOnly !== 'true') {
      result.exceededTransferLimit = geojson.metadata.limitExceeded || false
    }

    return result
  }

  /**
   * Convert GeoJSON geometry to Esri geometry format
   */
  convertGeometryToEsri(geometry) {
    if (!geometry) return null

    switch (geometry.type) {
      case 'Point':
        return {
          x: geometry.coordinates[0],
          y: geometry.coordinates[1]
        }
      case 'MultiPoint':
        return {
          points: geometry.coordinates
        }
      case 'LineString':
        return {
          paths: [geometry.coordinates]
        }
      case 'MultiLineString':
        return {
          paths: geometry.coordinates
        }
      case 'Polygon':
        return {
          rings: geometry.coordinates
        }
      case 'MultiPolygon':
        return {
          rings: geometry.coordinates.flat()
        }
      default:
        return null
    }
  }

  /**
   * Map geometry type to Esri format
   */
  mapGeometryTypeToEsri(geometryType) {
    const typeMap = {
      'Point': 'esriGeometryPoint',
      'MultiPoint': 'esriGeometryMultipoint',
      'LineString': 'esriGeometryPolyline',
      'MultiLineString': 'esriGeometryPolyline',
      'Polygon': 'esriGeometryPolygon',
      'MultiPolygon': 'esriGeometryPolygon'
    }
    return typeMap[geometryType] || 'esriGeometryPoint'
  }

  /**
   * Convert fields to Esri format
   */
  convertFieldsToEsri(fields) {
    if (!fields) return []

    return fields.map(field => ({
      name: field.name,
      type: this.mapFieldTypeToEsri(field.type),
      alias: field.alias || field.name,
      length: field.length || 255,
      nullable: true,
      defaultValue: null,
      modelName: field.name
    }))
  }

  /**
   * Map field type to Esri format
   */
  mapFieldTypeToEsri(fieldType) {
    const typeMap = {
      'String': 'esriFieldTypeString',
      'Integer': 'esriFieldTypeInteger',
      'Double': 'esriFieldTypeDouble',
      'Date': 'esriFieldTypeDate'
    }
    return typeMap[fieldType] || 'esriFieldTypeString'
  }

  /**
   * Convert relationships to Esri format
   */
  convertRelationshipsToEsri(relationships) {
    if (!relationships || !Array.isArray(relationships)) return []

    return relationships.map(rel => ({
      id: rel.id,
      name: rel.name,
      relatedTableId: rel.relatedTableId,
      cardinality: rel.cardinality,
      role: rel.role,
      keyField: rel.keyField,
      composite: rel.composite || false
    }))
  }

  /**
   * Generate layer info response
   */
  generateLayerInfo(metadata, params) {
    const isNonSpatial = !metadata.geometryType
    
    // Check if there are any date fields for temporal configuration
    const dateFields = metadata.fields ? metadata.fields.filter(field => field.type === 'Date') : []
    const hasDateFields = dateFields.length > 0
    
    // Determine if this should be a temporal layer
    // Check environment variable for temporal configuration
    const enableTemporal = process.env.KOOP_ENABLE_TEMPORAL === 'true'
    const temporalField = process.env.KOOP_TEMPORAL_FIELD || metadata.displayField
    
    const isTemporalLayer = enableTemporal && hasDateFields && temporalField && 
      dateFields.some(field => field.name === temporalField)
    
    const layerInfo = {
      id: parseInt(params.layer) || 0,
      name: metadata.name || params.id,
      type: isNonSpatial ? 'Table' : 'Feature Layer',
      description: metadata.description || '',
      geometryType: isNonSpatial ? null : this.mapGeometryTypeToEsri(metadata.geometryType),
      sourceSpatialReference: {
        wkid: 4326,
        latestWkid: 4326
      },
      copyrightText: '',
      parentLayer: null,
      subLayers: [],
      minScale: 0,
      maxScale: 0,
      defaultVisibility: true,
      extent: {
        xmin: metadata.extent[0][0],
        ymin: metadata.extent[0][1],
        xmax: metadata.extent[1][0],
        ymax: metadata.extent[1][1],
        spatialReference: {
          wkid: 4326,
          latestWkid: 4326
        }
      },
      hasAttachments: false,
      htmlPopupType: 'esriServerHTMLPopupTypeAsHTMLText',
      displayField: metadata.displayField || '',
      typeIdField: null,
      subtypeFieldName: null,
      subtypeField: null,
      defaultSubtypeCode: null,
      fields: this.convertFieldsToEsri(metadata.fields),
      geometryField: isNonSpatial ? null : {
        name: 'Shape',
        type: 'esriFieldTypeGeometry',
        alias: 'Shape'
      },
      indexes: [],
      subtypes: [],
      relationships: metadata.relationships || [],
      canModifyLayer: false,
      canScaleSymbols: false,
      hasLabels: false,
      capabilities: 'Map,Query,Data',
      maxRecordCount: metadata.maxRecordCount || parseInt(process.env.KOOP_MAX_RECORD_COUNT) || 100000,
      supportsStatistics: true,
      supportsAdvancedQueries: true,
      supportedQueryFormats: 'JSON, geoJSON',
      isDataVersioned: false,
      ownershipBasedAccessControlForFeatures: {
        allowOthersToQuery: true
      },
      useStandardizedQueries: true,
      advancedQueryCapabilities: {
        useStandardizedQueries: true,
        supportsStatistics: true,
        supportsHavingClause: true,
        supportsCountDistinct: true,
        supportsOrderBy: true,
        supportsDistinct: true,
        supportsPagination: true,
        supportsTrueCurve: true,
        supportsReturningQueryExtent: true,
        supportsQueryWithDistance: true,
        supportsSqlExpression: true
      },
      supportsDatumTransformation: true,
      supportsCoordinatesQuantization: true
    }
    
    // Add temporal configuration if this is a temporal layer
    if (isTemporalLayer) {
      layerInfo.timeInfo = {
        startTimeField: temporalField,
        endTimeField: null,
        trackIdField: null,
        timeExtent: null,
        timeReference: {
          timeZone: 'UTC',
          respectsDaylightSaving: false
        },
        hasLiveData: false,
        defaultTimeInterval: 1,
        defaultTimeIntervalUnits: 'esriTimeUnitsHours'
      }
      
      // Add temporal capabilities
      layerInfo.supportsTime = true
      layerInfo.timeInfo.exportOptions = {
        useTime: true,
        timeDataCumulative: false,
        timeOffset: null,
        timeOffsetUnits: null
      }
    } else {
      // Explicitly set timeInfo to null for non-temporal layers
      layerInfo.timeInfo = null
      layerInfo.supportsTime = false
    }
    
    return layerInfo
  }

  /**
   * Handle errors consistently
   */
  handleError(res, error) {
    console.error('PostgreSQL/PostGIS Provider Error:', error)
    
    const errorResponse = {
      error: {
        code: error.code || 500,
        message: error.message || 'Internal server error',
        details: []
      }
    }

    res.status(error.code || 500).json(errorResponse)
  }
}

module.exports = Controller
